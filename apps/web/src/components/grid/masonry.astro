---
import type { Cell } from '../../types';

// Import all cell components statically (required for server:defer)
import BedroomHumidity from './bedroom-humidity.astro';
import { LoadingFallback } from './loading-fallback';
// import CellPaint from './cells/cell-paint.astro';
// Add more imports here as you create them

interface Props {
  cells: Cell[];
  columns?: number;
  gap?: number;
  className?: string;
}

type PackedPosition = {
  xPct: number;
  widthPct: number;
  y: number;
  height: number;
};

type PackOptions = {
  minimizeWaste?: boolean;
  stretchBottom?: boolean;
};

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function simulateBottomsForHeight(
  positions: PackedPosition[],
  cells: Cell[],
  columns: number,
  gap: number,
) {
  const bottoms = new Array<number>(columns).fill(gap);

  positions.forEach((pos, idx) => {
    const span = clamp(cells[idx].width, 1, columns);
    const colStart = Math.round((pos.xPct / 100) * columns);
    const y = pos.y;
    const h = pos.height;
    for (let i = colStart; i < colStart + span; i++) {
      bottoms[i] = Math.max(bottoms[i], y + h + gap);
    }
  });

  return bottoms;
}

function packMasonryPercent(
  cells: Cell[],
  columns: number,
  gap: number,
  opts: PackOptions,
): { positions: PackedPosition[]; totalHeight: number } {
  const colPct = 100 / columns;
  const positions: PackedPosition[] = [];

  const columnBottoms = new Array<number>(columns).fill(gap);
  const lastIndexForColumn = new Array<number>(columns).fill(-1);

  cells.forEach((cell, index) => {
    const span = clamp(cell.width, 1, columns);

    let bestCol = 0;
    let bestMax = Number.POSITIVE_INFINITY;
    let bestWaste = Number.POSITIVE_INFINITY;

    for (let col = 0; col <= columns - span; col++) {
      const slice = columnBottoms.slice(col, col + span);
      const maxHeight = Math.max(...slice);
      if (opts.minimizeWaste) {
        const waste = slice.reduce((acc, h) => acc + (maxHeight - h), 0);
        if (maxHeight < bestMax || (maxHeight === bestMax && waste < bestWaste)) {
          bestMax = maxHeight;
          bestWaste = waste;
          bestCol = col;
        }
      } else {
        if (maxHeight < bestMax) {
          bestMax = maxHeight;
          bestCol = col;
        }
      }
    }

    const xPct = bestCol * colPct;
    const widthPct = span * colPct;
    const y = bestMax;
    const height = cell.height;

    positions.push({ xPct, widthPct, y, height });

    for (let i = bestCol; i < bestCol + span; i++) {
      columnBottoms[i] = y + height + gap;
      lastIndexForColumn[i] = index;
    }
  });

  if (opts.stretchBottom) {
    const targetBottom = Math.max(...columnBottoms);
    const extraByItem = new Map<number, number>();

    for (let c = 0; c < columns; c++) {
      const idx = lastIndexForColumn[c];
      if (idx === -1) continue;

      const currentBottom = columnBottoms[c];
      const leftover = targetBottom - currentBottom;
      if (leftover > 0) {
        extraByItem.set(idx, Math.max(extraByItem.get(idx) ?? 0, leftover));
      }
    }

    extraByItem.forEach((extra, idx) => {
      positions[idx].height += extra;
    });
  }

  const finalColumnBottoms = simulateBottomsForHeight(positions, cells, columns, gap);
  const totalHeight = Math.max(...finalColumnBottoms) + gap;

  return { positions, totalHeight };
}

const { cells, columns = 4, gap = 8, className = '' } = Astro.props;

const { positions, totalHeight } = packMasonryPercent(cells, columns, gap, {
  minimizeWaste: true,
  stretchBottom: true,
});

// Define which cells should be server islands (with defer)
// Add cell IDs here to make them load dynamically with fresh data
const serverIslands = new Set(['bedroom-humidity']);
---

<div class={className} style="position: relative;">
  <div style={`height: ${totalHeight}px; width: 100%; position: relative;`}>
    {
      cells.map((cell, index) => {
        const pos = positions[index];
        const isServerIsland = serverIslands.has(cell.id);

        return (
          <div
            class="absolute border overflow-hidden"
            style={`
            left: calc(${pos.xPct}% + ${gap}px);
            top: ${pos.y}px;
            width: calc(${pos.widthPct}% - ${gap * 2}px);
            height: ${pos.height}px;
          `}
          >
            {/* Render based on cell ID */}
            {cell.id === 'bedroom-humidity' ? (
              isServerIsland ? (
                <BedroomHumidity server:defer>
                  <LoadingFallback slot="fallback" />
                </BedroomHumidity>
              ) : (
                <BedroomHumidity />
              )
            ) : cell.id === 'cellpaint' ? (
              // Uncomment when you create this component:
              // isServerIsland ? (
              //   <CellPaint server:defer>
              //     <LoadingFallback slot="fallback" />
              //   </CellPaint>
              // ) : (
              //   <CellPaint />
              // )
              `Cell ${index}`
            ) : (
              `Cell ${index}`
            )}
          </div>
        );
      })
    }
  </div>
</div>
